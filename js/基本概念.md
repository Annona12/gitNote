### 语法

1. `区分大小写`
- ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。这也就意味着，变量名test和变量名Test分别表示两个不同的变量，而函数名不能使用 typeof，因为它是一个关键字（3.2 节介绍关键字），但 typeOf 则完全可以是一个有效的函数名
---
2. 标识符
(1)`所谓标识符，就是指变量、函数、属性的名字，或者函数的参数`。标识符可以是按照下列格式规则
组合起来的一或多个字符：
- `第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；`
- `其他字符可以是字母、下划线、美元符号或数字；`
- `标识符中的字母也可以包含扩展的ASCII或Unicode字母字符（如À和Æ），但我们不推荐这样做，ECMAScript标识符采用驼峰大小写格式。`
---
3. 注释
(1)ECMAScript 使用 C 风格的注释，包括`单行注释和块级注释`
- 单行注释以两个斜杠开头；
- 块级注释以一个斜杠和一个星号（/*）开头，以一个星号和一个斜杠（*/）结尾。
---
4. 严格模式
- (1)ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模型，要在整个脚本中启用严格模式，可以在顶部添加如下代码：
`"use strict"; `，这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），
用于告诉支持的 JavaScript 引擎切换到严格模式；
- (2)在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：
`function doSomething(){
 "use strict";
 //函数体
} `
---
5. 语句
ECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，虽然语句结尾的分号不是必需的，但我们`建议任何时候都不要省略它，`提高解析器解析代码的性能。
### 关键字和保留字
- (1)关键字：
`break do instanceof typeof
case else new var
catch finally return void
continue for switch while
debugger* function this with
default if throw
delete in try`
- (2)保留字：
`abstract enum int short
boolean export interface static
byte extends long super
char final native synchronized
class float package throws
const goto private transient
debugger implements protected volatile
double import public `
### 变量
(1)ECMAScript 的变量是松散类型的，`所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已`
- 有一点必须注意，即用` var 操作符定义的变量将成为定义该变量的作用域中的局部变量`。也就是说，如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁，省略 var 操作符可以定义全局变量；
- 可以使用一条语句定义多个变量，只要把每个变量（初始化或不初始化均可）用逗号分隔开即可；
- 在严格模式下，`不能定义名为 eval 或 arguments 的变量`，否则会导致语法错误。
### 数据类型
##### 数据类型
- (1)ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 6 种数据类型之一
- [ ] 1.`基本数据类型： Undefined、Null、Boolean、Number和 String`
- [ ] 2.`复杂数据类型：Object`
- (2)`typeof操作符`
1. 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型——typeof 就
是负责提供这方面信息的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串：
- `"undefined"——如果这个值未定义：`
- `"boolean"——如果这个值是布尔值；`
- `"string"——如果这个值是字符串；`
- `"number"——如果这个值是数值；`
- `"object"——如果这个值是对象或 null；`
- `"function"——如果这个值是函数。`
`typeof 操作符的操作数可以是变量（message），也可以是数值字面量。注意，
typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。`
##### 数据类型详情
- `Undefined`:该类型类型只有一个值，即特殊的 `undefined`。在使用 var 声明变量但未对其加以初始化时，
这个变量的值就是 undefined，对`未初始化和未声明的变量`执行 typeof 操作符都返回了 undefined 值，所以一般在申明的时候都会进行初始化
```
eg:
`var message;
alert(message == undefined); //true`
```
- `Null`：Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，`null 值表
示一个空对象指针`，而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因
```
`alert(null == undefined); //true`
```
- `Boolean`
Boolean 类型是 ECMAScript 中使用得最多的一种类型，区分大小写的，该类型只有两个字面值`true 和 false`。
这两个值与数字值不是一回事，因此` true 不一定等于 1，而 false 也不一定等于0`。
- [ ] 要将一个值转换为其对应的 Boolean 值，可以调用转型函数` Boolean()`
```
var message = "Hello world!";
var messageAsBoolean = Boolean(message);
数据类型 转换为true的值                   转换为false的值
Boolean   true                                 false
String    任何非空字符串                        ""（空字符串）
Number    任何非零数字值（包括无穷大）            0和NaN（参见本章后面有关NaN的内容）
Object    任何对象                                   任何对象 null
Undefined                                 undefined
```
- `Number`
- [ ] 浮点数值：所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小
数点前面可以没有整数，但我们不推荐这种写法。`保存浮点数值需要的内存空间是保存整数值的两倍`，因此 ECMAScript 会不失时机地将浮点数值转换为整数值,浮点数值的`最高精度是 17 位小数`

```
var floatNum1 = 1.1;
var floatNum2 = 0.1;
var floatNum3 = .1; // 有效，但不推荐
```
- [ ] 数值范围:`最小数值保存在 Number.MIN_VALUE `中——在大多数浏览器中，这个值是 `5e-324`；`最大数值保存在
Number.MAX_VALUE`中——在大多数浏览器中，这个值是 `1.7976931348623157e+30`。如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具
体来说，`如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转
换成 Infinity（正无穷）`。要想确定一个数值是不是有穷的（换句话说，是不是位于最
小和最大的数值之间），可以使用 `isFinite()函数`。这个函数在参数位于最小与最大数值之间时会返
回 true，如下面的例子所示：
```
eg:
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result)); //false 
```
- [ ] NaN:`NaN，即非数值（Not a Number）是一个特殊的数值`，这个数值用于表示一个本来要返回数值的操作数
未返回数值的情况（这样就不会抛出错误了）。`任何数值除以 0会返回 NaN`,NaN 本身有两个非同寻常的特点。首先，`任何涉及NaN的操作（例如NaN/10）都会返回NaN`，这个特点在多步计算中有可能导致问题。其次，`NaN 与任何值都不相等，包括 NaN 本身`,`isNaN()函数`,用于判断是不是NaN
```
eg:
alert(NaN == NaN); //false 
```

- [ ] 数值转换:有 3 个函数可以把非数值转换为数值`：Number()、parseInt()和 parseFloat()。`第一个函数即转型函数Number()可以用于`任何数据类型`，而另两个函数则专门用于把`字符串转换成数值`
-  Number()函数的转换规则如下。
- - 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。
- - 如果是数字值，只是简单的传入和返回。
- - 如果是 null 值，返回 0。
- - 如果是 undefined，返回 NaN。
- - 如果是字符串，遵循下列规则：
- - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"
会变成 1，"123"会变成 123，而"011"会变成 11（注意：前导的零被忽略了）；
- - 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽
略前导零）；
- - 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整
数值；
- - 如果字符串是空的（不包含任何字符），则将其转换为 0；
- - 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。
- - 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换
的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符
串值。
```
//为了更好地理解 parseInt()函数的转换规则，下面给出一些例子：
var num1 = parseInt("1234blue"); // 1234
var num2 = parseInt(""); // NaN
var num3 = parseInt("0xA"); // 10（十六进制数）
var num4 = parseInt(22.5); // 22
var num5 = parseInt("070"); // 56（八进制数）
var num6 = parseInt("70"); // 70（十进制数）
var num7 = parseInt("0xf"); // 15（十六进制数）
```
- String：
- [ ] ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变
某个变量保存的字符串，`首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量`，
- [ ] 要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 `toString()方法`,这个方法唯一要做的就是返回相应值的字符串表现,`数值、布尔值、对象和字符串值都有 toString()方法`,但 `null 和 undefined 值没有这个方法`
- [ ] String()函数遵循下列转换规则：
- - 如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果；
- - 如果值是 null，则返回"null"；
- - 如果值是 undefined，则返回"undefined"。
- Object：Object 的每个实例都具有下列属性和方法。
- [ ] ` constructor`：保存着用于创建当前对象的函数。
- [ ] `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例
的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例
如：o.hasOwnProperty("name")）。
- [ ] `isPrototypeOf(object)`：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原
型）。
- [ ] `propertyIsEnumerable(propertyName)`：用于检查给定的属性是否能够使用 for-in 语句
（本章后面将会讨论）来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符
串形式指定。
- [ ] `toLocaleString()`：返回对象的字符串表示，该字符串与执行环境的地区对应。
- [ ] `toString()`：返回对象的字符串表示。
- [ ] `valueOf()`：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值
相同。
### 操作符
### 语句
### 函数
1. 函数：实例ECMAScript 中的函数在定义时`不必指定是否返回值`,位于 return 语句之后的任何代码
都永远不会执行
```
function functionName(arg0, arg1,...,argN) {
 statements
}
以下是一个函数示例：
function sayHi(name, message) {
 alert("Hello " + name + "," + message);
} 
```
2. 严格模式对函数有一些限制：
- 不能把函数命名为 eval 或 arguments；
- 不能把参数命名为 eval 或 arguments；
- 不能出现两个命名参数同名的情况。
