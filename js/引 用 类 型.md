### Object类型
---
1. 虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择；
---
2. 创建 Object 实例的方式有两种
- 第一种是使用 new 操作符后跟 Object 构造函数
```
eg:
`var person = new Object();
person.name = "Nicholas";
person.age = 29;`
```
- 第二种方式是使用对象字面量表示法,在使用对象字面量语法时，属性名也可以使用字符串
```
eg:
`var person = {
 name : "Nicholas",
 age : 29
}; `
```
---
3. 在通过对象字面量定义对象时，实际上不会调用 Object 构造函数
---
4. 一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。
- JavaScript 也可以使用方括号表示法来访问对象的属性
```
eg:
`alert(person["name"]); //"Nicholas"
alert(person.name); //"Nicholas" `
```
- 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括
号表示法。例如：
`person["first name"] = "Nicholas";`
通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。
---

### Array类型
---
#### 数组的基础
1. 创建数组的基本方式：
- 第一种是使用 Array 构造函数，如下面的代码所示。
- [ ] `var colors = new Array(); `
如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值。例如，下面的代码将创建 length 值为 20 的数组。
- [ ] `var colors = new Array(20); `
也可以向 Array 构造函数传递数组中应该包含的项。以下代码创建了一个包含 3 个字符串值的数组：
- [ ] `var colors = new Array("red", "blue", "green");`
当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数
值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值
的只有一项的数组。下面就两个例子：
- [ ] `var colors = new Array(3); // 创建一个包含 3 项的数组
var names = new Array("Greg"); // 创建一个包含 1项，即字符串"Greg"的数组` 
另外，在使用 Array 构造函数时也可以省略 new 操作符。如下面的例子所示，省略 new 操作符的
结果相同：
- [ ] `var colors = Array(3); // 创建一个包含 3 项的数组
var names = Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组`
- 第二种基本方式是使用数组字面量表示法数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开，如下所示：
- [ ] `var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
var names = []; // 创建一个空数组
var values = [1,2,]; // 不要这样！这样会创建一个包含 2 或 3 项的数组
var options = [,,,,,]; // 不要这样！这样会创建一个包含 5 或 6 项的数组`
- 在像第四个省略值的情况下，每一项都将获得 undefined 值；这个结果与调用 Array 构造函数时传递项数在逻辑上是相同的
- 如果设置某个值的索引超过了数组现有项数，数组就会自动增加到该索引值加 1 的长度
- 数组的 length 属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项
---
#### 数组中的方法
1. 检测数组
- 确定某个对象是不是数组的问题：instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自
不同的构造函数。
- [ ] 使用 instanceof 操作符就能得到满意的结果
```
if (value instanceof Array){
 //对数组执行某些操作
} 
```
- [ ]  Array.isArray()方法：这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。
```
//这个方法的用法如下。
if (Array.isArray(value)){
 //对数组执行某些操作
} 
```
2. 转换方法
- `toLocaleString()`：toLocaleString()方法经常也会返回与 toString()和 valueOf()方法相同的值，但也
不总是如此。当调用数组的 toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符串
- `toString()`：toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串
- `valueOf()`： valueOf()返回的还是数组
- `join()`：只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。

```
var colors = ["red", "green", "blue"];
alert(colors.join(",")); //red,green,blue
alert(colors.join("||")); //red||green||blue 
```
```
var person1 = {
 toLocaleString : function () {
 return "Nikolaos";
 },

 toString : function() {
 return "Nicholas";
 }
};
var person2 = {
 toLocaleString : function () {
 return "Grigorios";
 },

 toString : function() {
 return "Greg";
 }
};
var people = [person1, person2];
alert(people); //Nicholas,Greg
alert(people.toString()); //Nicholas,Greg
alert(people.toLocaleString()); //Nikolaos,Grigorios
```

3. 栈方法
- `push()`：push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度
- `pop()`：pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项
- 
```
var colors =new Array(); // 创建一个数组
var count = colors.push("red", "green"); // 推入两项
alert(count); //2
count = colors.push("black"); // 推入另一项
alert(count); //3
var item = colors.pop(); // 取得最后一项
alert(item); //"black"
alert(colors.length); //2 
```
4. 队列方法
- `shift()`：它能够移除数组中的第一个项并返回该项，同时将数组长度减 1。
- `unshift()方法`：能在数组前端添加任意个项并返回新数组的长度
```
var colors = new Array(); //创建一个数组
var count = colors.push("red", "green"); //推入两项
alert(count); //2
count = colors.push("black"); //推入另一项
alert(count); //3
var item = colors.shift(); //取得第一项
alert(item); //"red"
alert(colors.length); //2



//同时使用 unshift()和 pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除//项，如下面的例子所示。
var colors = new Array(); //创建一个数组
var count = colors.unshift("red", "green"); //推入两项
alert(count); //2

count = colors.unshift("black"); //推入另一项
alert(count); //3
var item = colors.pop(); //取得最后一项
alert(item); //"green"
alert(colors.length); //2 
```
5. 重排序方法
- `reverse()`：reverse()方法会反转数组项的顺序
```
values.reverse();
alert(values); //5,4,3,2,1
```
- `sort()`：在默认情况下，sort()方法按升序排列数组项，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串，
```
var values = [0, 1, 5, 10, 15];
values.sort();
alert(values); //0,1,10,15,5
```
-  `sort()方法可以接收一个比较函数作为参数`，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数,只要将下列作为参数传递给 sort()方法即可
```
eg:
function compare(value1, value2) {
 if (value1 < value2) {
 return -1;
 } else if (value1 > value2) {
 return 1;
 } else {
 return 0;
 }
} 
```
`reverse()和 sort()方法的返回值是经过排序之后的数组。`
6. 操作方法
- concat()方法:基于当前数组中的所有项`创建一个新数组`,具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，`最后返回新构建的数组`。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的
每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾
```
`var colors = ["red", "green", "blue"];
var colors2 = colors.concat("yellow", ["black", "brown"]);
alert(colors); //red,green,blue
alert(colors2); //red,green,blue,yellow,black,brown`
```
- slice()方法:基于当前数组中的一或多个项创建一个新数组。
- [ ] slice()方法可以接受一或两个参数，即要返回项的起始和结束位置,在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项，如果有两个参数，该方法返回起始和结束位置之间的项—但不包括结束位置的项：`slice()方法不会影响原始数组`,
- [ ] 如果 slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含 5 项的数组上调用 slice(-2,-1)与调用slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组。
```
var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);
alert(colors2); //green,blue,yellow,purple
alert(colors3); //green,blue,yellow 

```
- `splice()`：它有很多种用法。splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种：
- [ ] 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。
例如，splice(0,2)会删除数组中的前两项。
- [ ] 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）
和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，
splice(2,0,"red","green")会从当前数组的位置 2 开始插入字符串"red"和"green"。
- [ ] 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起
始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，
splice (2,1,"red","green")会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串
"red"和"green"。
`splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何
项，则返回一个空数组）`
```
var colors = ["red", "green", "blue"];
var removed = colors.splice(0,1); // 删除第一项
alert(colors); // green,blue
alert(removed); // red，返回的数组中只包含一项
removed = colors.splice(1, 0, "yellow", "orange"); // 从位置 1 开始插入两项
alert(colors); // green,yellow,orange,blue
alert(removed); // 返回的是一个空数组
removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项
alert(colors); // green,red,purple,orange,blue
alert(removed); // yellow，返回的数组中只包含一项
```
7. 位置方法
> ECMAScript 5 为数组实例添加了两个位置方法：`indexOf()和 lastIndexOf()`。这两个方法都接收
两个参数：`要查找的项和（可选的）表示查找起点位置的索引`。其中，`indexOf()方法从数组的开头（位
置 0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找`。这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数
与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）。
```
var person = { name: "Nicholas" };
var people = [{ name: "Nicholas" }];
var morePeople = [person];
alert(people.indexOf(person)); //-1 `
```
8. 迭代方法
> ECMAScript 5 为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和
（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数
组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能
会也可能不会影响方法的返回值。
- `every()`：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。
```
`var numbers = [1,2,3,4,5,4,3,2,1];
var everyResult = numbers.every(function(item, index, array){
 return (item > 2);
});
alert(everyResult); //false`
```
- `filter()`：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。
```
 `var numbers = [1,2,3,4,5,4,3,2,1];
var filterResult = numbers.filter(function(item, index, array){
 return (item > 2);
});
alert(filterResult); //[3,4,5,4,3]`
```
- `forEach()`：对数组中的每一项运行给定函数。这个方法没有返回值。
```
`var numbers = [1,2,3,4,5,4,3,2,1];
numbers.forEach(function(item, index, array){
 //执行某些操作
}); `
```
- `map()`：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
```
 `var numbers = [1,2,3,4,5,4,3,2,1];
var mapResult = numbers.map(function(item, index, array){
 return item * 2;
});
alert(mapResult); //[2,4,6,8,10,8,6,4,2]`
```
- `some()`：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。
```
`var numbers = [1,2,3,4,5,4,3,2,1];
var someResult = numbers.some(function(item, index, array){
 return (item > 2);
});
alert(someResult); //true`
```
9. 归并方法
> ECMAScript 5 还新增了两个归并数组的方法：`reduce()和reduceRight()`。
这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这
个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第
一个参数是数组的第一项，第二个参数就是数组的第二项。
- `reduce()`：reduce()方法从数组的第一项开始，逐个遍历到最后
```
//使用 reduce()方法可以执行求数组中所有值之和的操作，比如：
`var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array){
 return prev + cur;
});
alert(sum); //15 `
```
- `reduceRight()`：reduceRight()则从数组的最后一项开始，向前遍历到第一项
```
reduceRight()的作用类似，只不过方向相反而已。来看下面这个例子。
`var values = [1,2,3,4,5];
var sum = values.reduceRight(function(prev, cur, index, array){
 return prev + cur;
});
alert(sum); //15`
```
---
### Date类型
1. 创建日期对象，使用 new 操作符和 Date 构造函数即可
```
var now = new Date();
```
在调用 `Date 构造函数`而不传递参数的情况下，新创建的对象自动获得`当前日期和时间`。如果想根据特定的日期和时间创建日期对象，必须传入表示该`日期的毫秒数`（即从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript提供了两个方法：`Date.parse()和 Date.UTC()。`
- `Date.parse()方法`接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日
期的毫秒数
- `Date.UTC()方法`同样也返回表示日期的毫秒数，但它与 Date.parse()在构建值时使用不同的信
息。`Date.UTC()的参数分别是年份、基于 0 的月份（一月是 0，二月是 1，以此类推）、月中的哪一天（1 到 31）、小时数（0 到 23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必
需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。`
```
//使用 Date.UTC()方法的例子：
// GMT 时间 2000 年 1 月 1 日午夜零时
var y2k = new Date(Date.UTC(2000, 0));
// GMT 时间 2005 年 5 月 5 日下午 5:55:55
var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); 
```
2. 日期格式化方法
Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。
-` oDateString()`——以特定于实现的格式显示星期几、月、日和年；
- `toTimeString()`——以特定于实现的格式显示时、分、秒和时区；
- `toLocaleDateString()`——以特定于地区的格式显示星期几、月、日和年；
- `toLocaleTimeString()`——以特定于实现的格式显示时、分、秒；
- `toUTCString()——以特定于实现的`toLocaleString()和 toString()`方法一样，以上这些字符串格式方法的输出也是因浏览器
而异的，因此没有哪一个方法能够用来在用户界面中显格式完整的 UTC 日期。
与 示一致的日期信息。
### RegExp类型
1. 创建正则表达式:ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。
```
var expression = / pattern / flags ;
```
其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，`可以包含字符类、限定符、分组、向前查找以及反向引用`。每个正则表达式都可带有`一或多个标志（flags）`，用以标明正则表达式的行为。
正则表达式的匹配模式支持下列 3 个标志。
- `g：表示全局（global）模式`，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即
停止；
- `i：表示不区分大小写（case-insensitive）模式`，即在确定匹配项时忽略模式与字符串的大小写；
- `m：表示多行（multiline）模式`，即在到达一行文本末尾时还会继续查找下一行中是否存在与模
式匹配的项。
```
/*
* 匹配字符串中所有"at"的实例
*/
var pattern1 = /at/g;
/*
* 匹配第一个"bat"或"cat"，不区分大小写
*/
var pattern2 = /[bc]at/i;
/*
* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写
*/
var pattern3 = /.at/gi;
与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：
( [ { \ ^ $ | ) ? * + .]} 
```
---
2. 创建正则表达式的方式是`使用RegExp构造函数`，它接收两个参数：`一个是要匹配的字符串模式，另一个是可选的标志字符串。`可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示。
```
/*
* 匹配第一个"bat"或"cat"，不区分大小写
*/
var pattern1 = /[bc]at/i;
/*
* 与 pattern1 相同，只不过是使用构造函数创建的
*/
var pattern2 = new RegExp("[bc]at", "i");
```
3. RegExp实例属性:RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
- `global：`布尔值，表示是否设置了 g 标志。
- `ignoreCase：`布尔值，表示是否设置了 i 标志。
- `lastIndex`：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。
- `multiline：`布尔值，表示是否设置了 m 标志。
- `source：`正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。
通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含
在模式声明中。
```
//例如：
var pattern1 = /\[bc\]at/i;
alert(pattern1.global); //false
alert(pattern1.ignoreCase); //true
alert(pattern1.multiline); //false
alert(pattern1.lastIndex); //0
alert(pattern1.source); //"\[bc\]at"
var pattern2 = new RegExp("\\[bc\\]at", "i");
alert(pattern2.global); //false
alert(pattern2.ignoreCase); //true
alert(pattern2.multiline); //false
alert(pattern2.lastIndex); //0
alert(pattern2.source); //"\[bc\]at" 
```
4. RegExp实例方法
- `RegExp 对象的主要方法是 exec()`，该方法是专门为捕获组而设计的。`exec()接受一个参数，即
要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。其中，index 表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。`在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。
```
//请看下面的例子。
var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi;
var matches = pattern.exec(text);
alert(matches.index); // 0
alert(matches.input); // "mom and dad and baby"
alert(matches[0]); // "mom and dad and baby"
alert(matches[1]); // " and dad and baby"
alert(matches[2]); // " and baby
```
- `正则表达式的第二个方法是test()`，`它接受一个字符串参数。在模式与该参数匹配的情况下返回
true；否则，返回 false。`在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的
情况下，使用这个方法非常方便。因此，test()方法经常被用在 if 语句中，

```
//如下面的例子所示。
var text = "000-00-0000";
var pattern = /\d{3}-\d{2}-\d{4}/;
if (pattern.test(text)){
 alert("The pattern was matched.");
} 
```
### Function类型

### 基本包装类型
1. Boolean类型

2. Number类型
3. String类型
4. 
### 单体内置对象
1. `Object、Array 和 String。`ECMA-262 还定义了两个单体内置对象：`Global 和 Math。`
2. `Global 和 Math。`
- Global:ECMAScript 中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没全局变量或全局函数；`所有在全局作用域中定义的属性和函数，都是 Global 对象的属性`。
- [ ] `URI 编码方法:`Global 对象的` encodeURI()和 encodeURIComponent()方法`可以对 URI（Uniform ResourceIdentifiers，通用资源标识符）进行编码，以便发送给浏览器
- [ ] `eval()方法:现在，`我们介绍最后一个——大概也是整个ECMAScript语言中最强大的一个方法：eval()。`eval()方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript（或 JavaScript）`字符串。`在eval()中创建的任何变量或函数都不会被提升，`因为在解析代码的时候，它们被包含在一个字
符串中；它们只在 eval()执行的时候创建。
```
eval("alert('hi')");
这行代码的作用等价于下面这行代码：
alert("hi"); 
```
- Math:
- [ ] `min()和 max()方法`
- [ ]` Math.ceil()执行向上舍入`，即它总是将数值向上舍入为最接近的整数；
- [ ] `Math.floor()执行向下舍入`，即它总是将数值向下舍入为最接近的整数；
- [ ]` Math.round()执行标准舍入`，即它总是将数值四舍五入为最接近的整数;
- [ ] `random()方法`
- [ ] `Math.abs(num) `返回num 的绝对值 Math.asin(x) 返回x 的反正弦值
- [ ] `Math.exp(num) `返回Math.E 的num 次幂 Math.atan(x) 返回x 的反正切值
- [ ] `Math.log(num) `返回num 的自然对数 Math.atan2(y,x) 返回y/x 的反正切值
- [ ] `Math.pow(num,power)` 返回num 的power 次幂 Math.cos(x) 返回x 的余弦值
- [ ] `Math.sqrt(num) `返回num 的平方根 Math.sin(x) 返回x 的正弦值
- [ ] `Math.acos(x)` 返回x 的反余弦值 Math.tan(x) 返回x 的正切值